# Negotiation / Counter-offer System (Production-ready Spec)

✅ **Purpose:** Define a realistic negotiation system for OpenGigs modeled on real platforms (Upwork/Fiverr patterns) that supports both chat-based discussions and structured counter-offers. This doc describes every case, the data model, chat design, API endpoints, UX, and acceptance criteria.

---

## Overview

Negotiation happens after a freelancer submits a proposal (`SUBMITTED`) and before a client hires (`ACCEPT & HIRE`). This document defines a **chat-first negotiation model** (no structured counter-offer endpoints). All negotiation and agreement happen through a proposal-scoped chat room; final hiring is performed explicitly by the client via `Accept & Hire`.

Negotiation must be safe, auditable, race-condition resistant, and well-integrated with chat for natural discussion.

### Job Types & Negotiable Terms

- **Fixed Price Jobs**: Client and freelancer negotiate on:
  - Project price/amount
  - Delivery timeline (days)
  
- **Hourly Rate Jobs**: Client and freelancer negotiate on:
  - Hourly rate
  - Total estimated hours needed
  - Deadline (by which the freelancer will complete the project)

---

## Actors

- Client (job owner)
- Freelancer (proposal owner)
- System (notifications, events)

---

## Cases & Exact System Behavior

### Case A — Accept & Hire (Happy path)

- Trigger: Client clicks **Accept & Hire** on a proposal.
- Server actions:
  1. Verify job is `OPEN`
  2. Atomically create Contract/Project record (DB transaction)
  3. Update Proposal.status -> `ACCEPTED`
  4. Update Job.status -> `IN_PROGRESS`
  5. Set all other proposals for job -> `REJECTED`
  6. Notify freelancer and client (push/email/in-app)
- Result: Work starts; chat continues inside the project workspace.

### Case B — Reject / Withdraw

- Who can reject: Client OR Freelancer
- Who can withdraw: Freelancer (can withdraw application anytime in SUBMITTED or NEGOTIATING status)
- Trigger: Either clicks **Reject** (visible based on role & status) or Freelancer clicks **Withdraw**
- Server actions:
  1. Set Proposal.status -> `REJECTED` (for reject) or `WITHDRAWN` (for freelancer withdrawal)
  2. Freeze proposal (read-only)
  3. Notify the counterparty
- Result: No further negotiation on that proposal; freelancer may bid on other jobs.

### Case C — Negotiate (Chat-first)

- Trigger: Freelancer submits a proposal. Client can then start negotiation with the freelancer by clicking **Counter Offer** on the proposal, which opens a new messaging tab within that job window.
- How it works:
  - Client can negotiate with 4-5 freelancers simultaneously, each in a separate messaging tab.
  - Freelancer sees the same interface but only with the client (one-to-one chat).
  - All negotiation happens via chat messages scoped to the proposal (one chat room per proposal).
  - Participants discuss price, delivery time, and scope naturally via messages and attachments.
  - No payment is required during negotiation; only finalized when both parties agree.
- Server actions:
  1. Create or use existing ChatRoom linked to the proposal and persist messages
  2. Set Proposal.status -> `NEGOTIATING` when the first negotiation message is posted
  3. Notify the counterparty of new messages
  4. Open new tab in job window for messaging with freelancer
- UI Flow:
  - After chat discussion is complete, the **client** can click **Submit Final Offer** with agreed terms.
  - The freelancer can then **Accept** or **Reject** the final offer.
  - Two action buttons are always available:
    1. **Close Conversation** - closes the chat if they cannot reach an agreement
    2. **Submit Final Offer** (client only) - client submits final offer with terms
  - If the freelancer accepts the final offer, the next steps begin (hiring/contract creation)
  - If the freelancer rejects, the conversation closes
  - **After final offer is submitted**, both parties can continue chatting. If they agree on different terms, the client can **modify the final offer** and resubmit it for the freelancer's acceptance

---

## Proposal Status Machine (final)

```

SUBMITTED
   |
   |----> WITHDRAWN (by freelancer)
   |
   |----> REJECTED (by client)
   |
   |----> NEGOTIATING
             |
             |----> ACCEPTED (both parties accept final offer)
             |
             |----> REJECTED (if final offer rejected)
             |
             |----> WITHDRAWN (by freelancer)
```

---

## Buttons Visibility & Permissions (UI)

### Freelancer
- SUBMITTED: Withdraw
- NEGOTIATING: Accept Final Offer / Reject Final Offer / Close Conversation
- ACCEPTED: Go to Project
- REJECTED: None
- WITHDRAWN: None

### Client (job owner)
- SUBMITTED: Counter Offer (opens messaging tab) / Reject
- NEGOTIATING: Submit Final Offer / Modify Final Offer / Close Conversation / Continue Negotiating with other freelancers
- ACCEPTED: View Project
- REJECTED: None

Notes:
- `Counter Offer` opens a new messaging tab within the job window for that specific freelancer.
- Client can have multiple conversations open for different freelancers simultaneously within the negotiation tab.
- Freelancer can withdraw their application at any time during SUBMITTED or NEGOTIATING status.
- Only the **client** can submit the final offer; the freelancer can accept or reject it.
- After final offer is submitted, if both parties agree on different terms during chat, the client can modify and resubmit the final offer.

---

## Data Model

### Proposal (excerpt)
```js
Proposal {
  _id: ObjectId,
  jobId: ObjectId,
  freelancerId: ObjectId,
  bidAmount: Number,
  currency: String,
  deliveryDays: Number,
  coverLetter: String,
  attachments: [String],
  status: String, // SUBMITTED | NEGOTIATING | ACCEPTED | REJECTED | WITHDRAWN
  // optional snapshot of agreed terms recorded by client when hiring or confirming
  agreedTerms: {
    amount: Number,
    days: Number,
    acceptedBy: String, // 'CLIENT' | 'FREELANCER' | null
    acceptedAt: Date
  },
  createdAt: Date,
  updatedAt: Date
}  

// Chat models remain central to negotiations (see ChatRoom and Message models below).
```
- Unique index `{ jobId, freelancerId }` enforced
- `negotiations` is append-only (audit trail)

### Chat models
```js
ChatRoom {
  _id: ObjectId,
  proposalId: ObjectId, // optional: link negotiation to a proposal
  jobId: ObjectId,
  participants: [ObjectId], // [clientId, freelancerId]
  createdAt: Date,
  lastMessageAt: Date
}

Message {
  _id: ObjectId,
  chatRoomId: ObjectId,
  senderId: ObjectId,
  text: String,
  attachments: [String],
  createdAt: Date,
  readBy: [ObjectId]
}
```

Design choices:
- One chat room per proposal (recommended) ensures messages are scoped to the negotiation.
- Chat is persisted and searchable for audits and disputes.

---

## APIs (examples)
Authentication: Bearer token; role checks

### Chat endpoints (chat-first negotiation)
- POST /api/proposals/:proposalId/chat
  - Body: { text, attachments? }
  - Auth: participant (client or freelancer)
  - Effects: create or use ChatRoom for proposal, persist Message, set Proposal.status -> `NEGOTIATING` if first negotiation message, notify other party
  - Errors: 403 if not a participant, 409 if proposal is `REJECTED` or `WITHDRAWN`

- GET /api/chat/:chatRoomId/messages?limit=50&before=messageId
  - Paginated fetch of messages

- WebSocket/Socket.IO events for real-time messages (subscribe to chatRoomId):
  - `message:create` to send message
  - `message:new` to receive broadcast messages

There are no structured negotiation endpoints in the chat-first approach; negotiation details are stored in chat messages and optionally captured in `agreedTerms` by the client when hiring.

### Chat endpoints & websocket events
- POST /api/proposals/:proposalId/chat (start chat / create room)
  - Creates ChatRoom if not exists, returns room meta

- GET /api/chat/:chatRoomId/messages?limit=50&before=messageId
  - Paginated fetch

- WS events (Socket.IO / WebSocket):
  - connect & auth with token
  - subscribe to chatRoomId
  - emit `message:create` { chatRoomId, text, attachments }
  - broadcast `message:new` to participants

Security & scaling:
- Use presence and pub/sub (Redis) for horizontal scaling
- Persist messages to DB and store attachments in object storage

---

## Sequences & Examples

### Example 1: Chat-first negotiation (Fixed Price Job)
1. Client clicks **Counter Offer** on a proposal → new messaging tab opens.
2. Client says in chat: "Can you do 4200 in 5 days?"
3. Freelancer replies: "Yes, I can do 4200 in 5 days."
4. Both parties agree on terms through chat.
5. Client clicks **Submit Final Offer** with the agreed terms (amount: 4200, delivery: 5 days).
6. Freelancer clicks **Accept Final Offer** → Contract created, Proposal.status -> `ACCEPTED`, Job -> `IN_PROGRESS`, others `REJECTED`.
7. Work begins.

### Example 1b: Chat-first negotiation (Hourly Rate Job)
1. Client clicks **Counter Offer** on a proposal → new messaging tab opens.
2. Client says in chat: "Can you do this at $50/hour? I estimate about 40 hours, and I need it done by March 15?"
3. Freelancer replies: "I can do $55/hour for 40 hours and finish by March 15."
4. Client agrees to the revised terms through chat.
5. Client clicks **Submit Final Offer** with the agreed terms (hourly rate: $55, total hours: 40, deadline: March 15).
6. Freelancer clicks **Accept Final Offer** → Contract created, Proposal.status -> `ACCEPTED`, Job -> `IN_PROGRESS`, others `REJECTED`.
7. Work begins.

### Example 2: Freelancer withdraws
- Freelancer clicks **Withdraw** anytime while status is `SUBMITTED` or `NEGOTIATING` -> set Proposal.status -> `WITHDRAWN` and notify client.

### Example 3: Client negotiates with multiple freelancers
1. Client has 3 open proposals for a job.
2. Client clicks **Counter Offer** on proposal A → negotiation tab opens with freelancer A's conversation.
3. Client clicks **Counter Offer** on proposal B → freelancer B's conversation appears in the same negotiation tab.
4. Client clicks **Counter Offer** on proposal C → freelancer C's conversation appears in the same negotiation tab.
5. Within the single negotiation tab, client can switch between conversations with all three freelancers (like a normal messaging app).
6. Each freelancer only sees their own conversation with the client.
7. Client and one freelancer reach agreement and client clicks **Submit Final Offer**.
8. Freelancer accepts the final offer → the job moves to IN_PROGRESS and the other two proposals are REJECTED.

---

## Notifications / Events
- CHAT_MESSAGE (new message in proposal chat)
- PROPOSAL_NEGOTIATION_CONFIRMED (optional: when client records agreed terms or hires)
- PROPOSAL_REJECTED
- PROPOSAL_WITHDRAWN
- FREELANCER_HIRED

Implement notification preferences (email, push, in-app) and digest strategies to avoid spam.

Implement notification preferences (email, push, in-app) and digest strategies to avoid spam.

---

## UX Patterns & Recommendations (OpenGigs)
- Provide prominent **Counter Offer** button on each proposal to open new messaging tabs within the job window
- Allow client to have multiple messaging tabs open for different freelancers, clearly labeled with freelancer names/avatars
- Show negotiation timeline (chat history) with timestamps and participants within each tab
- Rate-limit messages if necessary and confirm destructive actions (Reject, Close Conversation)
- Display **Submit Final Offer** and **Close Conversation** buttons prominently at the end of chat in the negotiation room
- Ensure final offer submission requires explicit acceptance from both parties before proceeding
- Show clear notifications when final offer is accepted or rejected

---

## Security, Integrity & Concurrency
- Use DB transactions when moving from `NEGOTIATING` to `ACCEPTED` and creating Contract to prevent double hires
- Enforce RBAC and validate participants on all negotiation/counter endpoints
- Rate-limit messages and counters; virus scan attachments
- Store negotiation history append-only for auditability

---

## Testing & Acceptance Criteria
- Chat room creation returns a room tied to proposal and persists messages
- Posting messages in proposal chat sets Proposal.status -> `NEGOTIATING` and notifies the other party
- Freelancer may indicate acceptance in chat, but only the client can trigger `Accept & Hire` to create a contract; test that hiring requires client action and is atomic
- Reject marks proposal read-only and notifies counterparty
- Withdraw works in SUBMITTED/NEGOTIATING and prevents further actions
- Concurrency tests: two users trying to hire same proposal -> only one succeeds

---

## Admin & Moderation
- Admin tools to view full negotiation threads and chat logs for disputes
- Ability to redact or mute abusive users and remove attachments

---

## Migration & Implementation Notes
- Add `negotiations` array and `ChatRoom` + `Message` collections
- Add indexes: `chatRoomId` on messages, `proposalId` on chat rooms and negotiations
- Use socket auth and Redis pub/sub for message delivery at scale

---

## Example payloads
- Create counter:
```json
POST /api/proposals/613b.../negotiations
{ "amount": 4200, "days": 5, "message": "Can you do 4200 in 5 days?" }
```

- Chat message over socket:
```json
emit('message:create', { "chatRoomId": "abc123", "text": "I can do 5 days for 4200", "attachments": [] })
```

---

If you want, I can also:
- Generate Mongoose models (`models/Negotiation.js`, `models/ChatRoom.js`, `models/Message.js`)
- Implement route handlers and socket handlers
- Create sample UI wireframes for proposal negotiation page

---

*Document created: a comprehensive negotiation & chat design for production implementation.*
