# Chat, Negotiation & Hire Module Documentation

## Overview

This module handles real-time negotiation, structured counter-offers, agreement generation, and the hire flow. It ensures legal clarity and prevents disputes by separating human conversation (chat) from contract data (proposal & agreement).

### Job Types & Negotiable Terms
- **Fixed Price Jobs**: Client and freelancer negotiate on:
  - Project price/amount
  - Delivery timeline (days)
  
- **Hourly Rate Jobs**: Client and freelancer negotiate on:
  - Hourly rate
  - Total estimated hours needed
  - Deadline (by which the freelancer will complete the project)

---

## 1Ô∏è‚É£ Chat System Architecture (Socket.io)

### Core Concept

**Context-based chat**: Every chat belongs to a specific proposal/job, not a global messaging system.

```
Chat Room = Specific to Job + Proposal
```

---

### 1.1 Database Models

#### ChatRoom Model

```javascript
const chatRoomSchema = new Schema({
  _id: ObjectId,
  
  jobId: {
    type: Schema.Types.ObjectId,
    ref: 'Job',
    required: true
  },
  
  proposalId: {
    type: Schema.Types.ObjectId,
    ref: 'Proposal',
    required: true
  },
  
  clientId: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  
  freelancerId: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  
  status: {
    type: String,
    enum: ['ACTIVE', 'ARCHIVED', 'CLOSED'],
    default: 'ACTIVE'
  },
  
  lastMessageAt: Date,
  
  createdAt: {
    type: Date,
    default: Date.now
  }
});
```

#### Message Model

```javascript
const messageSchema = new Schema({
  _id: ObjectId,
  
  chatRoomId: {
    type: Schema.Types.ObjectId,
    ref: 'ChatRoom',
    required: true,
    index: true
  },
  
  senderId: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  
  type: {
    type: String,
    enum: ['TEXT', 'FILE', 'SYSTEM', 'OFFER'],
    default: 'TEXT'
  },
  
  content: {
    type: String,
    required: true
  },
  
  // For file messages
  fileUrl: String,
  fileName: String,
  fileSize: Number,
  fileType: String,
  
  // For offer messages (system tracking)
  offerData: {
    offerId: Schema.Types.ObjectId,
    type: String, // 'COUNTER_OFFER' | 'OFFER_ACCEPTED' | 'OFFER_REJECTED'
    amount: Number,
    days: Number,
    status: String
  },
  
  isEdited: {
    type: Boolean,
    default: false
  },
  
  editedAt: Date,
  
  isDeleted: {
    type: Boolean,
    default: false
  },
  
  deletedAt: Date,
  
  reactions: [{
    userId: Schema.Types.ObjectId,
    emoji: String
  }],
  
  createdAt: {
    type: Date,
    default: Date.now,
    index: true
  }
});
```

---

### 1.2 Chat Room Creation Triggers

Chat room is created automatically when:

**Trigger 1: Client Initiates Negotiation**
```
Client clicks "Counter Offer" on proposal
  ‚Üí ChatRoom created with:
    - jobId
    - proposalId
    - clientId
    - freelancerId
    - Proposal.status ‚Üí NEGOTIATING
```

**Trigger 2: Reopen Existing Chat**
```
Client clicks "Counter Offer" on same proposal again
  ‚Üí Use existing ChatRoom
  ‚Üí Continue conversation
```

---

### 1.3 Real-Time Features with Socket.io

#### Socket.io Room Structure

```javascript
// User joins chat room
socket.join(`chatRoom_${chatRoomId}`)
```

#### Socket Events

**User connects to chat:**
```javascript
socket.on('chat:open', (chatRoomId) => {
  socket.join(`chatRoom_${chatRoomId}`)
  io.to(`chatRoom_${chatRoomId}`).emit('user:online', {
    userId: socket.userId,
    timestamp: new Date()
  })
})
```

**Send message:**
```javascript
socket.on('message:send', (data) => {
  // Validate & sanitize
  // Check keyword blocking
  // Save to DB
  // Broadcast to room
  
  io.to(`chatRoom_${data.chatRoomId}`).emit('message:new', {
    messageId,
    senderId,
    content,
    timestamp
  })
})
```

**Typing indicator:**
```javascript
socket.on('typing:start', (chatRoomId) => {
  io.to(`chatRoom_${chatRoomId}`).emit('user:typing', {
    userId: socket.userId,
    typing: true
  })
})

socket.on('typing:stop', (chatRoomId) => {
  io.to(`chatRoom_${chatRoomId}`).emit('user:typing', {
    userId: socket.userId,
    typing: false
  })
})
```

**User disconnect:**
```javascript
socket.on('disconnect', () => {
  io.to(`chatRoom_${chatRoomId}`).emit('user:offline', {
    userId: socket.userId,
    timestamp: new Date()
  })
})
```

---

### 1.4 Keyword Blocking (Phone & Email)

**Implementation:**

```javascript
// In message:send handler
const MESSAGE_REGEX = {
  PHONE: /(\+\d{1,3}[-.\s]?)?\d{3,4}[-.\s]?\d{3,4}[-.\s]?\d{4}/,
  EMAIL: /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/,
  WHATSAPP: /(whatsapp|whatsapp me|wa\.me)/i,
  TELEGRAM: /(telegram|@[a-zA-Z0-9_]+)/i
}

function checkContentSafety(content) {
  let modifiedContent = content
  let hasBlockedContent = false
  
  // Check for email
  if (MESSAGE_REGEX.EMAIL.test(content)) {
    modifiedContent = content.replace(MESSAGE_REGEX.EMAIL, '***')
    hasBlockedContent = true
  }
  
  // Check for phone
  if (MESSAGE_REGEX.PHONE.test(content)) {
    modifiedContent = content.replace(MESSAGE_REGEX.PHONE, '***')
    hasBlockedContent = true
  }
  
  return {
    isBlocked: hasBlockedContent,
    originalContent: content,
    modifiedContent: modifiedContent,
    warning: hasBlockedContent ? 
      'For your safety, do not share contact details outside OpenGigs.' : null
  }
}

// Usage
const safety = checkContentSafety(messageContent)
if (safety.isBlocked) {
  // Send system message warning
  // Save message with masked content
  // Notify sender of blocked content
}
```

---

### 1.5 Chat UI Context Display

At the top of every chat window, display job context:

```javascript
{
  jobTitle: "Build ecommerce website",
  jobBudget: 25000,
  proposalAmount: 24000,
  proposalDelivery: 7,
  jobCategory: "Web Development",
  jobPostedAt: "2026-01-10T10:30:00Z"
}
```

---

## 2Ô∏è‚É£ Negotiation System (Counter-Offers)

### Core Principle

**Chat = Human Discussion**
**Proposal Record = Legal Source of Truth**

> ‚ö†Ô∏è The system NEVER reads final amount/days from chat messages.
> 
> Instead, use structured **Counter-Offer** actions.

---

### 2.1 Counter-Offer Model

```javascript
const counterOfferSchema = new Schema({
  _id: ObjectId,
  
  proposalId: {
    type: Schema.Types.ObjectId,
    ref: 'Proposal',
    required: true
  },
  
  jobId: {
    type: Schema.Types.ObjectId,
    ref: 'Job',
    required: true
  },
  
  // Only client can send final offer
  senderId: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
    // Must be clientId
  },
  
  receiverId: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
    // Must be freelancerId
  },
  
  // For Fixed Price Jobs
  counterAmount: {
    type: Number,
    min: 0
  },
  
  counterDays: {
    type: Number,
    min: 1
  },
  
  // For Hourly Rate Jobs
  hourlyRate: {
    type: Number,
    min: 0
  },
  
  totalHours: {
    type: Number,
    min: 1
  },
  
  deadline: {
    type: Date
  },
  
  jobType: {
    type: String,
    enum: ['FIXED_PRICE', 'HOURLY_RATE'],
    required: true
  },
  
  message: String,
  
  status: {
    type: String,
    enum: ['PENDING', 'ACCEPTED', 'REJECTED'],
    default: 'PENDING'
  },
  
  respondedAt: Date,
  
  expiresAt: {
    type: Date,
    default: () => new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
  },
  
  createdAt: {
    type: Date,
    default: Date.now
  }
});
```

---

### 2.2 Final Offer Submission Flow

> üîë **Key Concept:** 
> - Client can **DRAFT** a final offer and chat about it
> - While in DRAFT, client can **EDIT** the terms
> - Once SUBMITTED, the offer is sent to freelancer
> - Freelancer can only ACCEPT or REJECT (no re-negotiation)
> - **If REJECTED ‚Üí Chat room CLOSES immediately**

**Flow:**
1. **Client clicks "Create Final Offer"** ‚Üí Form opens (DRAFT state)
2. **Client fills amount/days** ‚Üí Can discuss in chat before submitting
3. **Client can EDIT** offer multiple times while still in DRAFT
4. **Client clicks "Submit"** ‚Üí Final offer sent to freelancer (PENDING state)
5. **Freelancer responds:**
   - **ACCEPT** ‚Üí Move to agreement generation
   - **REJECT** ‚Üí Negotiation room closes, chat ends
6. **No re-negotiation after rejection** ‚Üí Client must submit new proposal to try again

---

### 2.3 Negotiation Flow - Detailed Steps

#### Step 1: Initial Proposal

```
Freelancer submits proposal:
{
  proposalAmount: 4500
  proposalDays: 5
  status: "PENDING"
}
```

#### Step 2: Client Negotiates & Drafts Final Offer

**Chat Discussion:**
```
Client: "Can you do ‚Çπ4200 in 6 days?"
Freelancer: "That might work, let me check my schedule."
Client: "Actually, let me adjust to ‚Çπ4300 for better quality"
```

> üí° **During DRAFT phase:** Client discusses and can EDIT the final offer multiple times before submitting.

**Action:** Client clicks "Submit Final Offer" (sends to freelancer)

```javascript
POST /api/proposals/:proposalId/final-offer
{
  jobType: "FIXED_PRICE",
  counterAmount: 4200,
  counterDays: 6,
  message: "Can you do this amount in 6 days?" // Optional
}
```

**Response:**
```json
{
  "success": true,
  "data": {
    "offerId": "507f1f77bcf86cd799439050",
    "proposalId": "507f1f77bcf86cd799439011",
    "senderId": "507f1f77bcf86cd799439010", // Client
    "receiverId": "507f1f77bcf86cd799439012", // Freelancer
    "counterAmount": 4200,
    "counterDays": 6,
    "jobType": "FIXED_PRICE",
    "status": "PENDING",
    "expiresAt": "2026-01-18T10:30:00Z",
    "message": "Can you do this amount in 6 days?"
  }
}
```

**System Action:**
- Create Counter-Offer record
- Broadcast to freelancer in real-time
- Send notification to freelancer

#### Step 3: Freelancer Responds (Accept OR Reject - No Middle Ground)

**Option A: Freelancer Accepts**

```javascript
POST /api/final-offers/:offerId/accept
```

**Response:**
```json
{
  "success": true,
  "data": {
    "offerId": "507f1f77bcf86cd799439050",
    "status": "ACCEPTED",
    "proposalUpdated": {
      "proposalId": "507f1f77bcf86cd799439011",
      "finalAmount": 4200,
      "finalDays": 6,
      "status": "AGREED"
    },
    "nextStep": "Agreement will be generated",
    "message": "Offer accepted! Agreement document is being generated."
  }
}
```

**System Actions:**
```javascript
// Update Proposal
proposal.finalAmount = 4200
proposal.finalDays = 6
proposal.status = "AGREED"

// Create Agreement (auto-generated)
// Send both parties agreement for review
```

---

**Option B: Freelancer Rejects**

```javascript
POST /api/final-offers/:offerId/reject
{
  reason: "I cannot accept this rate"
}
```

**Response:**
```json
{
  "success": true,
  "data": {
    "offerId": "507f1f77bcf86cd799439050",
    "status": "REJECTED",
    "message": "Negotiation ended. Chat room closed."
  }
}
```

---

**After Rejection:** The negotiation room **closes immediately**. The client and freelancer **cannot continue chatting**. Negotiation ends.

> ‚ö†Ô∏è **Important:** Before submitting a final offer, the **client can edit the offer and both parties can discuss the terms in chat**. Once the client clicks "Submit" to send the final offer to the freelancer, the offer goes live. If the freelancer rejects it, the negotiation room closes and they cannot re-negotiate. The only way to negotiate again is if the client submits a new proposal from scratch.

---

### 2.3 Counter-Offer History

**Endpoint:** `GET /api/proposals/:proposalId/final-offers`

**Response:**
```json
{
  "success": true,
  "data": {
    "proposalId": "507f1f77bcf86cd799439011",
    "negotiationHistory": [
      {
        "round": 1,
        "initiator": "CLIENT",
        "jobType": "FIXED_PRICE",
        "amount": 4200,
        "days": 6,
        "status": "REJECTED",
        "createdAt": "2026-01-10T10:30:00Z"
      },
      {
        "round": 2,
        "initiator": "CLIENT",
        "jobType": "FIXED_PRICE",
        "amount": 4300,
        "days": 5,
        "status": "ACCEPTED",
        "createdAt": "2026-01-10T11:30:00Z"
      }
    ],
    "finalAgreedAmount": 4300,
    "finalAgreedDays": 5,
    "proposalStatus": "AGREED"
  }
}
```

---

## 3Ô∏è‚É£ How System Determines Final Amount & Days

### The Correct Design

```
‚úÖ Chat messages = Discussion only
‚úÖ Final Offer object = Source of truth for final terms (client submits only)
‚úÖ Proposal object = Stores finalAmount & finalDays after freelancer acceptance
```

### Data Flow (Fixed Price Job)

```
1. Initial Proposal
   ‚îú‚îÄ proposalAmount: 4500
   ‚îî‚îÄ proposalDays: 5

2. Chat: "Can you do 4200 in 6 days?"

3. Client submits Final Offer
   ‚îú‚îÄ counterAmount: 4200
   ‚îî‚îÄ counterDays: 6

4. Freelancer accepts Final Offer

5. System updates Proposal
   ‚îú‚îÄ finalAmount: 4200
   ‚îú‚îÄ finalDays: 6
   ‚îî‚îÄ status: "AGREED"

6. Agreement generated with final values
```

### Data Flow (Hourly Rate Job)

```
1. Initial Proposal
   ‚îú‚îÄ proposedHourlyRate: 50
   ‚îî‚îÄ estimatedHours: 40

2. Chat: "Can you do $55/hour for 40 hours, deadline March 15?"

3. Client submits Final Offer
   ‚îú‚îÄ hourlyRate: 55
   ‚îú‚îÄ totalHours: 40
   ‚îî‚îÄ deadline: "2026-03-15"

4. Freelancer accepts Final Offer

5. System updates Proposal
   ‚îú‚îÄ finalHourlyRate: 55
   ‚îú‚îÄ finalTotalHours: 40
   ‚îú‚îÄ finalDeadline: "2026-03-15"
   ‚îî‚îÄ status: "AGREED"

6. Agreement generated with final values
```

### Why This Works

‚úÖ **Legal clarity**: Terms are structured, not inferred from chat  
‚úÖ **Dispute prevention**: All changes tracked with timestamps  
‚úÖ **Audit trail**: Full negotiation history preserved  
‚úÖ **Database consistency**: Single source of truth per field  
‚úÖ **Easy enforcement**: Can directly reference in contract  
‚úÖ **Clear responsibility**: Only client can submit final terms

---

## 4Ô∏è‚É£ Next Steps

After freelancer accepts the final offer:

1. **Agreement Generated** - See [9.AGREEMENT-HIRING.md](9.AGREEMENT-HIRING.md) for complete agreement generation, electronic signing, and hiring workflow
2. **Digital Signatures** - Both parties digitally sign the agreement
3. **Project Created** - Upon full signature, project workspace is initialized

> üìå **Note**: Agreement generation, digital signature process, and hiring flow are detailed in a separate document to maintain separation of concerns.

---

## 5Ô∏è‚É£ API Endpoints Summary

### Chat Endpoints

| Method | Endpoint | Purpose |
|--------|----------|---------|
| POST | `/api/proposals/:proposalId/chat` | Open chat (create or reopen) |
| GET | `/api/chat/:chatRoomId/messages` | Get chat messages |
| POST | `/api/proposals/:proposalId/final-offer` | Client submits final offer |
| POST | `/api/final-offers/:offerId/accept` | Freelancer accepts offer |
| POST | `/api/final-offers/:offerId/reject` | Freelancer rejects offer |
| PUT | `/api/chat/message/:messageId` | Edit message |
| DELETE | `/api/chat/message/:messageId` | Delete message |
| GET | `/api/proposals/:proposalId/final-offers` | View negotiation history |

### Counter-Offer / Final-Offer Endpoints

| Method | Endpoint | Purpose |
|--------|----------|---------|
| POST | `/api/proposals/:proposalId/final-offer` | Client submits final offer (fixed or hourly) |
| GET | `/api/proposals/:proposalId/final-offers` | Get all final offers history |
| POST | `/api/final-offers/:offerId/accept` | Freelancer accepts final offer |
| POST | `/api/final-offers/:offerId/reject` | Freelancer rejects final offer |

---

## 6Ô∏è‚É£ Socket.io Events Summary

### Client ‚Üí Server Events

```javascript
// Chat
socket.emit('chat:open', { chatRoomId })
socket.emit('message:send', { chatRoomId, content })
socket.emit('typing:start', { chatRoomId })
socket.emit('typing:stop', { chatRoomId })

// User presence
socket.emit('user:online', { chatRoomId })
socket.emit('user:offline', { chatRoomId })
```

### Server ‚Üí Client Events

```javascript
// Messages
socket.on('message:new', (data) => {})
socket.on('message:edited', (data) => {})
socket.on('message:deleted', (data) => {})

// User presence
socket.on('user:online', (data) => {})
socket.on('user:offline', (data) => {})
socket.on('user:typing', (data) => {})

// Final Offers (only client submits)
socket.on('offer:submitted', (data) => {})
socket.on('offer:accepted', (data) => {})
socket.on('offer:rejected', (data) => {})
socket.on('offer:modified', (data) => {})
```

---

## 7Ô∏è‚É£ Key Principles

### Design Principles

‚úÖ **Separation of Concerns**
- Chat for discussion
- Proposal for data
- Agreement for legal terms (separate doc)
- Project for execution

‚úÖ **Legal Clarity**
- All contract terms in Agreement (separate doc)
- Structured counter-offers (not chat text)
- Both parties sign digitally (see Agreement doc)
- Audit trail complete

‚úÖ **Prevents Disputes**
- No ambiguity on final terms
- Written agreement signed (see Agreement doc)
- Full negotiation history
- Timestamps on everything

‚úÖ **Platform Security**
- No contact sharing allowed
- Keyword blocking enforced
- Payment locked in escrow (see Agreement doc)
- All actions logged

‚úÖ **Real-Time Engagement**
- Live typing indicators
- Instant notifications
- Real-time presence
- Smooth UX

---

## 8Ô∏è‚É£ Error Handling

### Common Scenarios

**Counter-Offer Expired:**
```json
{
  "success": false,
  "error": "Counter-offer has expired",
  "code": "OFFER_EXPIRED",
  "statusCode": 400,
  "expiresAt": "2026-01-18T10:30:00Z"
}
```

**Invalid Job Type:**
```json
{
  "success": false,
  "error": "Invalid job type for negotiation",
  "code": "INVALID_JOB_TYPE",
  "statusCode": 400
}
```

---

## 9Ô∏è‚É£ Implementation Checklist

### Database Models
- [ ] Update ChatRoom model
- [ ] Create Message model with keyword blocking
- [ ] Create FinalOffer model
- [ ] Update Proposal model with finalAmount/finalDays

### Controllers
- [ ] Create `chatController.js`
- [ ] Create `finalOfferController.js`
- [ ] Update `proposalController.js`

### Routes
- [ ] Create `chatRoutes.js`
- [ ] Create `finalOfferRoutes.js`

### Socket.io
- [ ] Set up Socket.io server
- [ ] Implement chat rooms
- [ ] Implement typing indicators
- [ ] Implement user presence
- [ ] Implement real-time offer notifications

### Business Logic
- [ ] Keyword blocking function
- [ ] Final-offer acceptance flow
- [ ] Real-time presence tracking
- [ ] Message persistence

### Frontend
- [ ] Chat UI with context
- [ ] Final offer UI
- [ ] Real-time notifications
- [ ] Message editing/deletion UI

### Security
- [ ] Rate limiting on messages
- [ ] Prevent unauthorized chat access
- [ ] Validate input sanitization
- [ ] Log all critical actions

---

## 1Ô∏è‚É£0Ô∏è‚É£ Summary Table

| Component | Purpose | Real-time |
|-----------|---------|-----------|
| **Chat** | Human discussion | ‚úÖ Yes |
| **FinalOffer** | Structured negotiation | ‚è±Ô∏è Polling |
| **Proposal** | Negotiation state | ‚è±Ô∏è Polling |
| **Escrow** | Payment security | ‚úÖ Yes (see Agreement doc) |

---

## References

- **Agreement & Hiring**: [9.AGREEMENT-HIRING.md](9.AGREEMENT-HIRING.md)
- **Project Workspace**: [8.PROJECT-WORKSPACE.md](8.PROJECT-WORKSPACE.md)
- **Project Payment**: [6.PROJECT-PAYMENT.md](6.PROJECT-PAYMENT.md)

---

## Next Steps

1. Implement database models
2. Build chat backend with Socket.io
3. Create final-offer API
4. Build frontend UI
5. See [9.AGREEMENT-HIRING.md](9.AGREEMENT-HIRING.md) for agreement generation and hiring
6. Test complete negotiation flow end-to-end
7. Deploy and monitor

*Document updated: Negotiation Chat focused on communication and final offer submission only.*
  